Technical Challenge for the 2023 Funded Game Development Bootcamp, Hosted by TheDeveloperAcademy. 

This code is licensed under the MIT License. 
## Build Instructions
### Windows
- Install CMake 3.12 or higher
- Clone the repository, and enter its directory. 
```bash
git clone https://github.com/ewanburnett/GDB-Tech-Test.git
cd GDB-Tech-Test
```
- Enter the following commands 
```bash
mkdir build
cd build
cmake ..
```
- Open the Visual Studio Solution generated by CMake, and build. 
### Linux
- Install CMake 3.12 or higher
- Clone the repository, and enter its directory. 
```bash
git clone https://github.com/ewanburnett/GDB-Tech-Test.git
cd GDB-Tech-Test
```
- Build the project using CMake
```bash
mkdir build
cd build
cmake ..
make
```

## Architecture
"Given an array of objects, each consisting of a 2D location, ID number, and cardinal direction, Write a function returning any points which intersect the visible range of a given cone."

A number of new types are used for convenience, including a basic 2-Dimensional Vector, An Enumeration for direction definitions, and a container for each entity. 
```mermaid
classDiagram
	EDirection -- Entity
	Vector2 -- Entity
	class Vector2{
		+float x
		+float y
	}
	
	class EDirection{
		NORTH
		SOUTH
		EAST
		WEST
	}
	
	class Entity{
		+int ID
		+Vector2 position
		+EDirection direction
	}
```

The following pseudocode gives an overview of the algorithm used.
```javascript
list<Entity> world;
//...
list<int> VisiblePoints(Entity e, float FoV, float distance){
	list<int> intersections;
	for(other : world){
		//Establish whether this entity intersects with the sphere originating from e, with radius of distance. 
		if(VectorLength2D(other.position - e.position) > radius)
			continue; //This entity is outside of the bounding sphere, so skip it. 
		//Compare the angle between this entity and the other entity with our FoV. 
		
		//The angle between this entity and the other entity. Both vectors need to be normalized.
		toOther = Normalize(other.position - e.position);
		fDotOther = Dot(e.direction, toOther);
		//The start and end angles of our FoV
		startAngle = atan2(Normalize(e.direction - toOther));
		endAngle = atan2(Normalize(e.direction + toOther));

		//As long as the angle to the other entity is within our range, an intersection has occurred. 
		if(startAngle < fDotOther && fDotOther < endAngle){
			intersections.push(other.ID);
		}
	}

	return intersections;
}
```

### Mathematical Definitions
#### 2D Dot Product 
The Dot Product gives the angle between two vectors, in Radians. 
$$dot_{(a, b)} = (a_x * b_x) + (a_y * b_y) = |a||b|\cos(\theta) $$
#### 2D Vector Length
The 2D Length of a Vector is identical to Pythagoras' Theorem. 
$$
|(x, y)| = length_{(x, y)} = \sqrt{x^2 + y^2}
$$
#### Normalization
Normalizing a Vector divides it by its length, in effect mapping it to the range $${(0, 0)} \le {(x, y)} \le {(1, 1)} 
$$$$||(x, y)|| = normalize_{(x, y)}= \frac {(x,y)}{|(x, y)|} = \frac {(x, y)}{\sqrt{(x^2+y^2)}}$$
#### Sphere Intersection
If the distance between points a and b is less than or equal to the radius of the sphere originating at point a, then point b intersects. 
```c++
bool Intersects(Vector2 center, float radius, Vector2 point){
	Vector2 toPoint = point - center;
	if(Vector2::Length(toPoint) > radius){
		return false;    //The point lies outside of the sphere's radius. 
	}
	return true; 
}
```

## Tests
All tests are run on the following dataset, found within TestData.csv

| X | Y | Number | Direction |
|-|-|-|-|
| 28| 42| 1| North|
|27|46|2|East|
|16|22|3|South|
|40|50|4|West|
|8|6|5|North|
|6|19|6|East|
|28|5|7|South|
|39|36|8|West|
|12|34|9|North|
|36|20|10|East|
|22|47|11|South|
|33|19|12|West|
|41|18|13|North|
|41|34|14|East|
|14|29|15|South|
|6|49|16|West|
|46|50|17|North|
|17|40|18|East|
|28|26|19|South|
|2|12|20|West|


